## 1. C++的三个主要性质：
封装性、继承性、多态性
## 2. 动态分配
    利用定义的指针p，给如下定义的结构类型动态分配(用new运算符)20个元素结构体数组的

语句:【1】。假如已包含所需的头文件。

     struct student{char name[20];int ID;flost fscor;};

     struct student *p;

(答案1)=======

p = new student[20];

或=========

p★=★new student★[★20★]★;

或=========

p = new struct student[20];

或=========

p★=★new struct student★[★20★]★;



## 3.  算法的特征包括
有穷性、确定性、输入性、输出性可行性

## 4. 是否控制求值顺序
逻辑与、逻辑或、条件操作符会控制求值顺序

设有：

    int x = 2,y = 2, a;

    a = (x = x + 1)||(y = y + 1);

执行后变量x,y,a的值分别是（）。

A:3,3,0

B:3,2,1

C:3,3,1

D:3,2,0

答案：B

## 5. 运算符优先顺序

算术运算符>关系运算符>逻辑运算符>赋值运算符

## 6. 指针
有如下定义，**不能**表示数组元素a\[2]\[3]的是：（）。   

    int a[3][4] = {{1,4,7,10},{2,5,8,11},{3,6,9,12}};

    int *pa[3] = {a[0],a[1],a[2]};

    int (*pb)[4] = a;

    int **q = pa;

A:\*(a\[2] + 3)

B:\*(\*(pa + 2) + 3)

C:\*(pb + 2)\[3]

D:q\[2]\[3]

答案：C

## 7. 文件读写长度
已知：

    char str[80]

    fstream inFile;

    inFile.open("s.txt", ios::in);

    if (!inFile){

        exit(1);

    }

    inFile.getline(str, 80);

A:字符串读入后不会自动加入'\0'

B:s.txt不存在也可正常运行

C:getline将从文件中最多读入79个字符

D:getline将从文件中最多读入80个字符

答案：C

## 8. 奇特的运算
已知所有头文件已经包含，下列程序运行结果是（）。   

\#define  A  2

\#define  AA  A+A/2

int main(void)

{       

    cout  << AA << "," << 5 * AA;

    return 0;

}

A:3,11

B:3,15

C:2,10

D:8,40

答案：A

## 9.条件运算符优先级高于赋值运算符
以下程序的执行结果是（）。

\#include \<iostream>

using namespace std;

int  main(void)

{

    int  w = 1, x = 2, y = 3, z = 4;

    w =( w < x ) ? x : w;

    w =( w < y ) ? y : w;

    w =( w < z ) ? z : w;

    cout <<  w;

    return 0;

 }

A:1

B:2

C:3

D:4

答案：D


## 10. 控制数据精度
使变量A精度为1e-6，等价于A>1e-6

## 11. 十六进制字符串转为无符号短整型

本质上是将十六进制转换为十进制吗？
题目： 函数的功能是将输入的16进制字符串（不超过四位）转换为

  无符号短整型。数参数中的字符指针，传递16进制字符串地

  址。返回值为转换结果。

  如输入：1a4b，或1A4B或1a4B

  输出为：6731
**思维**：n=0；n\*16+对应位的十进制，然后循环。


```
#include <iostream>

#include <iomanip>

#include <fstream>

#include <cstdlib>

using namespace std;

unsigned short fun(char *);//原型声明

void SaveRes(void);



unsigned short fun(char *p)

{

/***********************program*************************/

/*************************END***************************/

}

int main(void)

{

    char str[20];

    unsigned short n;

    cout << "Input a Hex string (<= 4)：";

    cin.getline(str, 80);

    n = fun(str);

    cout << "结果为:" << n;

    SaveRes();

    return 0;

}

//以下部分与编程无关，切勿修改！

void SaveRes(void)

{

    fstream inFile, outFile;

    char szBuff[80];

    unsigned short d;

    inFile.open ("in0103.dat",ios::in);

    if(!inFile)

    {

        cout << "File open error!";

        exit(1);

    }

    outFile.open("out0103.dat",ios::out);

    if(!outFile)

    {

        cout << "File open error!";

        inFile.close();

        exit(1);

    }

    inFile.getline(szBuff, 80);

    d = fun(szBuff);

    outFile << d;

    inFile.close();

    outFile.close();

}

答案：    unsigned short n = 0;

    while (*p)
    {

        if (*p >= '0' && *p <= '9')

        {

            n = n * 16 + *p - '0';

        }

        if (*p >= 'a' && *p <= 'f')

        {

            n = n * 16 + *p - 'a' + 10;

        }

        if (*p >= 'A' && *p <= 'F')

        {

            n = n * 16 + *p - 'A' + 10;

        }

        p++;

    }

    return n;
```

## 12. 二维数组的加法
```
#include <iostream>

using namespace std;

int main(void)

{

    int i;

    char s[4][5]={"ABCD","EFGH","IJKL", "MNOP"};

    for (i = 0; i < 4; i++){

        cout << s[i] + i;  //是地址加上i个整型的地址

    }

    return 0;

}

A:ABCDEFGHIJKLMNOP

B:BCDFGHJKLNOP

C:ABCDFGHKLP

D:ABCDFJN

答案：C



void test01() {
	char a[3][7] = { "ABCD","EFG","HI" };
	for (int i = 0; i < 3; i++) {
		cout << a[i] + i << endl;//二维字符数组a[i]+i是地址加上i个字符型的地址,遇到\0时停止输出
	}
}

void test02() {
	int a[] = { 1,2,3 };
	for (int i = 0; i < 3; i++) {
		cout << a[i] + i << endl;//一维数组a[i]+i是数值加上i
	}
}

void test03() {
	int a[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	for (int i = 0; i < 3; i++) {
		cout << *(a[i] + i) << endl;//二维整型数组a[i]+i是地址加上i个整型得到的是地址
	}
}
```
## 13. 删除字符串中的数字字符，并调整顺序
```

	int i, k=0;
	for (i = 0; p[i] != '\0'; i++) {
		if ((p[i] >= 'A' && p[i] <= 'Z') || (p[i] >= 'a' && p[i] <= 'z')) {
			p[k] = p[i];
			k++;
		}
	}
	p[k] = '\0';
```
## 14. 判断是否为升序数
升序数是指一个正整数（含0）从左到右的每一位数都大于等于前一位数
n = d0d1d2..dm,升序数的条件是：d0≤d1≤d2...≤dm

**思路**：先判断合法性（是否为正整数含0），再判断是否为升序数（相邻两位比，abcd，先比d与c，再c与d）

```
没有判断合法性
int test02(int a) {
	int i = 0;
	int t,d;
	t = a % 10;
	while (a>0) {
		d = a % 10;
		if (d > t) {
			return 0;
		}
		t = d;
		a /= 10;
	}
	return 1;
}
```

## 15. fabs（A）返回A的绝对值

## 16. 将b进制（2~10）的字符串（无符号）转为十进制

```
int func(char *a,int b) {
	int sum = 0;
	while (*a) {
		if (*a > '0' && *a < '0' + b) {
			sum = sum * b + *a - '0';
		}
		else {
			return -1;
		}
		a++;
	}
	return sum;
}
```

## 17. 构造和析构顺序

```
#include <iostream.h>

class exam

{

     int a;

   public:

     exam(int i=0)

     {  a=i;  cout<<"constructor "<<a<<endl;  }

     ~exam()

     {  cout<<"deconstructor "<<a<<endl; }

     void print()

     {  cout<<a<<endl; }

};

void main()

{

  exam ob;

  ob=4;

  ob.print();

  ob=exam(8);

  ob.print();

}
```
![[Pasted image 20221209165542.png]]


## 18.不同继承方式中派生类成员对基类成员的访问权限
任意一种继承方式下，**派生类类中**均可访问基类public和protected成员，但是**保护继承和私有继承的派生类对象**无法直接访问基类public和pretected成员，共有继承的派生类对象可以直接访问基类public成员。
pretected成员在类外都无法访问（除非是友元）。
总结：通过类成员**只能**直接访问公有成员，以及**公有继承**的共有成员！任意一种继承方式下，**派生类类中**均可访问基类public和protected成员