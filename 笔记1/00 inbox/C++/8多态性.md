## 8.1 多态性

### 8.1.1 定义

操作接口（根据操作环境的不同）采用不同的处理方式

### 8.1.2 分类

多态的类型

重载多态  强制多态  包含多态  参数多态

按多态性作用的时机分

编译时的多态  运行时的多态
“绑定”

## 8.2 运算符重载

### 8.2.1 作用

对已有的运算符赋予多重含义，同一个运算符处理不同类型的数据

### 8.2.2 规则

几乎所有的运算符都能重载（重载C++中已有的），不能重载："." ".*" "::" "?:"

重载运算符的优先级和结合性都不会改变

两种重载方式

类的非静态成员函数  非成员函数

### 8.2.3 运算符重载为成员函数

**形式**

返回值类型 operator 运算符 （形参）{  ……  }

**参数**

重载为类成员函数：参数个数=原操作数个数-1  （后置++、--除外）

（重载为非成员函数：参数个数=原操作数个数，且有一个**自定义类型的新参**）

**双目运算符B**

表达式：P1  B  P2，（P为类，P1、P2类对象）。  
B重载为P类的成员函数，其形参应该为P2的类型，此时为P类。

则表达式P1  B P2相当于P1.operator B(P2)

**后置单目运算符++和--**

对于后置单目运算符，重载函数需要有一个**整型形参**,但不必写形参名。

形式：**类名** operator 运算符 (int)  
Clock operator ++ (int){ }

在调用后置单目运算符时，无需输入形参： (***）

### 8.2.4 运算符重载为非成员函数

**作为类的友元函数**

当运算符的重载函数需要操作某类对象的私有成员，可将其声明为该类的友元

**后置单目运算符**

形参列表中增加一个int，无需写形参名。  
假设重载后置单目运算符B  
形式：返回值类型 operator B (int a,int) { }

**例子**

-   双目运算符 B重载后，  
    表达式oprd1 B oprd2  
    等同于operator B(oprd1,oprd2 )
-   前置单目运算符 B重载后，  
    表达式 B oprd  
    等同于operator B(oprd )
-   后置单目运算符 ++和--重载后，  
    表达式 oprd B  
    等同于operator B(oprd,0 )

## 8.3 虚函数
### 8.3.1 定义

（实现运行时的多态）

用**virtual**关键字说明的函数。

声明：

virtual 函数类型 函数名（形参表）
{

        函数体

}

是实现运行时多态性基础

C++中的虚函数是动态绑定的函数

必须是非静态的成员函数。

经过派生后，就可以实现运行过程中的多态。  
**在派生类中可以对基类中的成员函数进行覆盖（重定义）。**

### 8.3.2 虚析构函数

**可通过基类指针删除派生类对象。**
//基类指针指向派生类对象。使用delete只能析构基类，在基类的析构函数前加virtual则可同时析构基类和派生类。

如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数成为虚函数，否则执行delete的结果是不确定的。

## 8.4 抽象类

### 8.4.1 纯虚函数

是一个在基类中声明的虚函数，在该基类中无具体操作内容，各派生类根据实际情况定义自己的版本。 声明：

virtual 函数类型 函数名 （参数表） =0；

### 8.4.2抽象类

**定义**

带有纯虚函数的类称为抽象类

**目的**

实现抽象和设计。将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。