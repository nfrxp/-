## 例1——求素数(1~200)。
解：int i, j;
       1.试除法
           境界1：j(2~i-1)
           境界2：j(2~i/2)
           境界3：j(2~i的算术平方根)
           境界4：j(2以及2~i的算术平方根之间的奇数)
           境界5：i(除2以外，其余素数全为奇数)
           境界6：j(小于i的算术平方根的素数)
                         j(2以及2~ide算术平方根之间的奇数   而3、5、11、13···的倍数均不用除如9、21)
                         如果i不是从2开始，j就不用取2。
           以空间换时间
       2.筛法
![[0@ClippedImage 1.png]]



## 例2——输出字符串（以及单个字符）
![[4@ClippedImage 1.png]]




![[5@ClippedImage 1.png]]



## 例3——参数传值与传址

![[1@ClippedImage 1.png]]



## 例4 ——扫雷思路

![[2@attach_221008_100305_008 1.jpg]]


## 例5——运算符优先级
![[Pasted image 20221207231502.png]]



## 例6——ASCII码
![[9@ClippedImage 1.png]]

## 例7——求x的y次方

![[11@ClippedImage 1.png]]
## 例8——递归（阶乘、汉诺塔）


## 例9——面试   数据类型（u)

![[13@ClippedImage 1.png]]

在任何不同数据类型的二元运算中，例如：a + b
较低数据类型的操作数在执行操作之前总是自动类型转换为较高数据类型的操作数，结果将是较高数据类型。
众所周知，运算符享有比二元运算符更高的优先级。所以我们的表达是：
x = 10 + (-10u) + 10u + (-10);
  = 10 + -10 + 10 + (-10)；
  = 0
注意：有符号是比无符号整数更高的数据类型。
因此，无符号 10u 的对应有符号值为 +10





![[14@ClippedImage 1.png]]





We cannot predict the value of volatile variable because its value can be changed by any microprocessor interrupt.

## 例11——如何辨别进制
c里面，0开头的数字都当作八进制，0x开头的被当作十六进制。

## 例12——数据类型
![[17@ClippedImage 1.png]]


## 类-开发人员命令提示符

![[6@ClippedImage 1.png]]


![[18@ClippedImage 1.png]]


## 例13—— 交换两个变量（不创建临时变量）
![[20@ClippedImage 1.png]]

## 例14——指针加法
设有 
      char  *p="12345";
      cout << p + 1;


	      输出是：2345 

## 例15——动态分配
C++可以通过new分配内存，定义了如下指针：
    int *p;
通过new分配20个元素的数组的语句：___。

p=new int[20];





## 例16——不创建零时变量，交换两值 （或者使用按位异或）
若有以下程序段：
    int a = 3, b = 4;  
    a = a + b;
    b = a - b;
    a = a - b;
则执行以上语句后，a和b的值分别是（）。

A:a = 3,  b = 3
B:a = 3,  b = 4
C:a = 4,  b = 4
D:a = 4,  b = 3


答案：D



## 例17——自定义标识符（英文字母或者下划线开头）
以下一组都是合法c++用户标识符的是（）。
A:iFlag, _st, x1, int
B:_float, x1, iCout, define
C:x2, 2y, define, b
D:x.12, y2, fSum, dPre


答案：B




## 例18——何时&&视为&
下列程序段的输出结果是____。 
  
    int a,b,d=25;
    a = d / 8 % 9;
    b = a && (-1);
    cout << a <<  "," << b;

A:6,1
B:3,1
C:6,0
D:3,0


答案：B



## 例19——取反
如果定义变量：unsigned short a = 0x0f0f;与表达式~a等价的表达式是：（）


A:!a
B:a & 0xffff
C:a ^ 0xffff
D:a | 0x0000


答案：C



## 例20——main函数位置

C 语言规定，在一个源程序中，main函数的位置（可以任意）

## 例21——C程序的基本组成单位
 C程序的基本组成单位是函数

## 例22——C输入输出
 C语言本身没有输入输出语句

## 例23——指针加法
若有定义语句：int year=1009,*p=&year;以下不能使变量 year 中的值增至 1010 的语句是（）
A *p+=1;
B (*p)++;
C ++(*p)
D *p++

正确答案： D
D选项 单目运算符从右至左，先地址++，再取值；


## 例24——自动类型转换
char a; int b; float c; double d;
则表达式 a*b+d-c 值的类型为（）
A float
B int
C char
D double
他的回答： D (正确)
正确答案： D
参考答案：
正确答案：D


自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。
例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
char 和 short 参与运算时，必须先转换成 int 类型。
**自动类型转换，本质上是为了保证数据精度转换按数据长度增加的方向进行**


## 例25——求最小公倍数
求最小公倍数

标题： | 时间限制：1秒 | 内存限制：32768K | 语言限制： 不限

正整数A和正整数B的**最小公倍数是**指能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。

数据范围：1<a,b<100000

输入描述，输入两个正整数A和B。
输出描述，输出A和B的最小公倍数。

示例1 输入5 7   输出35

**代码**
'#include<stdio.h>                //求最小公倍数

int main() {

int i=1, a, b;                                //比把公倍数从1开始检验更高效

scanf("%d %d", &a, &b);

while (a * i % b != 0)                //设a*i为最小公倍数

i++;

printf("%d", a * i);

return 0;

}'


## 例26——逆序字符串
如I like Beijing. ->.gnijieB ekil I
**思路**:将left和right替换，将left-1和right-1替换，依次进行，直到两坐标相等
#gets(A)
将标准输入流中的字符串读取给A，可读取空格，以回车作为读取结束标志
#strlen（A）与sizeof（A）
## 例27——倒置单词排序
【倒置字符串】将一句话的**单词进行倒置**，标点不倒置。比如 I like beijing. 经过函数后变为：beijing. like I
输入描述：
输出描述：
示例1：
输入I like beijing.
输出beijing. like I

每个测试输入包含1个测试用例： I like beijing. 输入用例长度不超过100
依次输出倒置之后的字符串,以空格分割
**思路**：先**逆序**字符串，再**逆序**每个单词。是否有特殊情况？

## 例28——求x的n次方
#pow(double x, double n)
返回值类型为double
引用头文件<math.h>

